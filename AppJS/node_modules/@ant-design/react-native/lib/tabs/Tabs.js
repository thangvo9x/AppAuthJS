"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tabs = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _createSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/createSuper"));

var _react = _interopRequireDefault(require("react"));

var _reactNative = require("react-native");

var _reactNativePagerView = _interopRequireDefault(require("react-native-pager-view"));

var _style = require("../style");

var _view = _interopRequireDefault(require("../view"));

var _DefaultTabBar = require("./DefaultTabBar");

var _tabs = _interopRequireDefault(require("./style/tabs"));

var instanceId = 0;

var Tabs = /*#__PURE__*/function (_React$PureComponent) {
  (0, _inherits2["default"])(Tabs, _React$PureComponent);

  var _super = (0, _createSuper2["default"])(Tabs);

  function Tabs(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, Tabs);
    _this = _super.call(this, props);
    _this.tabCache = {};

    _this.renderContent = function () {
      var getSubElements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.getSubElements();
      var _this$props = _this.props,
          tabs = _this$props.tabs,
          usePaged = _this$props.usePaged,
          destroyInactiveTab = _this$props.destroyInactiveTab;
      var _this$state = _this.state,
          _this$state$currentTa = _this$state.currentTab,
          currentTab = _this$state$currentTa === void 0 ? 0 : _this$state$currentTa,
          _this$state$container = _this$state.containerWidth,
          containerWidth = _this$state$container === void 0 ? 0 : _this$state$container;
      var content = tabs.map(function (tab, index) {
        var key = tab.key || "tab_".concat(index); // update tab cache

        if (_this.shouldRenderTab(index)) {
          _this.tabCache[index] = _this.getSubElement(tab, index, getSubElements);
        } else if (destroyInactiveTab) {
          _this.tabCache[index] = undefined;
        }

        return /*#__PURE__*/_react["default"].createElement(_view["default"], {
          key: key,
          // active={currentTab === index}
          style: {
            width: containerWidth
          }
        }, _this.tabCache[index]);
      });
      return /*#__PURE__*/_react["default"].createElement(_reactNativePagerView["default"], {
        key: "$content",
        keyboardDismissMode: "on-drag",
        initialPage: currentTab,
        scrollEnabled: _this.props.swipeable || usePaged,
        onPageScroll: function onPageScroll(e) {
          _this.state.scrollX.setValue(e.nativeEvent.position * _this.state.containerWidth);
        },
        style: {
          flex: 1
        },
        onPageSelected: function onPageSelected(e) {
          var index = e.nativeEvent.position;

          _this.setState({
            currentTab: index
          }, function () {
            // tslint:disable-next-line:no-unused-expression
            _this.props.onChange && _this.props.onChange(tabs[index], index);
          });

          _this.nextCurrentTab = index;
        },
        ref: function ref(_ref) {
          return _this.viewPager = _ref;
        }
      }, content);
    };

    _this.onMomentumScrollEnd = function (e) {
      var offsetX = e.nativeEvent.contentOffset.x;

      var page = _this.getOffsetIndex(offsetX, _this.state.containerWidth);

      if (_this.state.currentTab !== page) {
        _this.goToTab(page);
      }
    };

    _this.handleLayout = function (e) {
      var width = e.nativeEvent.layout.width;
      requestAnimationFrame(function () {
        _this.scrollTo(_this.state.currentTab, false);
      });

      if (Math.round(width) !== Math.round(_this.state.containerWidth)) {
        _this.setState({
          containerWidth: width
        });
      }
    };

    _this.scrollTo = function (index) {
      var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (_this.viewPager) {
        if (animated) {
          _this.viewPager.setPage(index);
        } else {
          _this.viewPager.setPageWithoutAnimation(index);
        }

        return;
      }
    };

    _this.isTabVertical = function () {
      var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.props.tabDirection;
      return direction === 'vertical';
    };

    _this.shouldRenderTab = function (idx) {
      var _this$props$prerender = _this.props.prerenderingSiblingsNumber,
          prerenderingSiblingsNumber = _this$props$prerender === void 0 ? 0 : _this$props$prerender;
      var _this$state$currentTa2 = _this.state.currentTab,
          currentTab = _this$state$currentTa2 === void 0 ? 0 : _this$state$currentTa2;
      return currentTab - prerenderingSiblingsNumber <= idx && idx <= currentTab + prerenderingSiblingsNumber;
    };

    _this.getOffsetIndex = function (current, width) {
      var threshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _this.props.distanceToChangeTab || 0;
      var ratio = Math.abs(current / width);
      var direction = ratio > _this.state.currentTab ? '<' : '>';
      var index = Math.floor(ratio);

      switch (direction) {
        case '<':
          return ratio - index > threshold ? index + 1 : index;

        case '>':
          return 1 - ratio + index > threshold ? index : index + 1;

        default:
          return Math.round(ratio);
      }
    };

    _this.getSubElements = function () {
      var children = _this.props.children;
      var subElements = {};
      return function () {
        var defaultPrefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '$i$-';
        var allPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '$ALL$';

        if (Array.isArray(children)) {
          children.forEach(function (child, index) {
            if (child.key) {
              subElements[child.key] = child;
            }

            subElements["".concat(defaultPrefix).concat(index)] = child;
          });
        } else if (children) {
          subElements[allPrefix] = children;
        }

        return subElements;
      };
    };

    var width = _reactNative.Dimensions.get('window').width;

    var pageIndex = _this.getTabIndex(props);

    _this.state = {
      currentTab: pageIndex,
      scrollX: new _reactNative.Animated.Value(pageIndex * width),
      scrollValue: new _reactNative.Animated.Value(pageIndex),
      containerWidth: width
    };
    _this.nextCurrentTab = _this.state.currentTab;
    _this.instanceId = instanceId++;
    return _this;
  }

  (0, _createClass2["default"])(Tabs, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      this.prevCurrentTab = this.state.currentTab;
      this.state.scrollX.addListener(function (_ref2) {
        var value = _ref2.value;
        var scrollValue = value / _this2.state.containerWidth;

        _this2.state.scrollValue.setValue(scrollValue);
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      var _this$props2 = this.props,
          tabBarPosition = _this$props2.tabBarPosition,
          noRenderContent = _this$props2.noRenderContent,
          keyboardShouldPersistTaps = _this$props2.keyboardShouldPersistTaps;
      var _this$state2 = this.state,
          scrollX = _this$state2.scrollX,
          scrollValue = _this$state2.scrollValue,
          containerWidth = _this$state2.containerWidth; // let overlayTabs = (this.props.tabBarPosition === 'overlayTop' || this.props.tabBarPosition === 'overlayBottom');

      var overlayTabs = false;
      var tabBarProps = (0, _extends2["default"])((0, _extends2["default"])({}, this.getTabBarBaseProps()), {
        keyboardShouldPersistTaps: keyboardShouldPersistTaps,
        scrollX: scrollX,
        scrollValue: scrollValue,
        containerWidth: containerWidth
      });

      if (overlayTabs) {// tabBarProps.style = {
        //     position: 'absolute',
        //     left: 0,
        //     right: 0,
        //     [this.props.tabBarPosition === 'overlayTop' ? 'top' : 'bottom']: 0,
        // };
      }

      return /*#__PURE__*/_react["default"].createElement(_style.WithTheme, {
        styles: this.props.styles,
        themeStyles: _tabs["default"]
      }, function (styles) {
        var content = [/*#__PURE__*/_react["default"].createElement(_view["default"], {
          key: "$tabbar",
          style: tabBarPosition === 'top' ? styles.topTabBarSplitLine : styles.bottomTabBarSplitLine
        }, _this3.renderTabBar(tabBarProps, _DefaultTabBar.DefaultTabBar)), !noRenderContent && _this3.renderContent()];
        return /*#__PURE__*/_react["default"].createElement(_view["default"], {
          style: [styles.container, _this3.props.style],
          onLayout: _this3.handleLayout
        }, tabBarPosition === 'top' ? content : content.reverse());
      });
    }
  }, {
    key: "getTabIndex",
    value: function getTabIndex(props) {
      var page = props.page,
          initialPage = props.initialPage,
          tabs = props.tabs;
      var param = (page !== undefined ? page : initialPage) || 0;
      var index = 0;

      if (typeof param === 'string') {
        tabs.forEach(function (t, i) {
          if (t.key === param) {
            index = i;
          }
        });
      } else {
        index = param || 0;
      }

      return index < 0 ? 0 : index;
    }
  }, {
    key: "UNSAFE_componentWillReceiveProps",
    value: function UNSAFE_componentWillReceiveProps(nextProps) {
      if (this.props.page !== nextProps.page && nextProps.page !== undefined) {
        this.goToTab(this.getTabIndex(nextProps), true);
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.prevCurrentTab = this.state.currentTab;
    }
  }, {
    key: "goToTab",
    value: function goToTab(index) {
      var _this4 = this;

      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var newState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (!force && this.nextCurrentTab === index) {
        return false;
      }

      this.nextCurrentTab = index;
      var _this$props3 = this.props,
          tabs = _this$props3.tabs,
          onChange = _this$props3.onChange;

      if (index >= 0 && index < tabs.length) {
        if (!force) {
          // tslint:disable-next-line:no-unused-expression
          onChange && onChange(tabs[index], index);
        }

        this.setState((0, _extends2["default"])({
          currentTab: index
        }, newState), function () {
          requestAnimationFrame(function () {
            _this4.scrollTo(_this4.state.currentTab, _this4.props.animated);
          });
        });
      }

      return true;
    }
  }, {
    key: "tabClickGoToTab",
    value: function tabClickGoToTab(index) {
      this.goToTab(index);
    }
  }, {
    key: "getTabBarBaseProps",
    value: function getTabBarBaseProps() {
      var currentTab = this.state.currentTab;
      var _this$props4 = this.props,
          animated = _this$props4.animated,
          onTabClick = _this$props4.onTabClick,
          tabBarActiveTextColor = _this$props4.tabBarActiveTextColor,
          tabBarBackgroundColor = _this$props4.tabBarBackgroundColor,
          tabBarInactiveTextColor = _this$props4.tabBarInactiveTextColor,
          tabBarPosition = _this$props4.tabBarPosition,
          tabBarTextStyle = _this$props4.tabBarTextStyle,
          tabBarUnderlineStyle = _this$props4.tabBarUnderlineStyle,
          renderTab = _this$props4.renderTab,
          renderUnderline = _this$props4.renderUnderline,
          tabs = _this$props4.tabs;
      return {
        activeTab: currentTab,
        animated: !!animated,
        goToTab: this.tabClickGoToTab.bind(this),
        onTabClick: onTabClick,
        tabBarActiveTextColor: tabBarActiveTextColor,
        tabBarBackgroundColor: tabBarBackgroundColor,
        tabBarInactiveTextColor: tabBarInactiveTextColor,
        tabBarPosition: tabBarPosition,
        tabBarTextStyle: tabBarTextStyle,
        tabBarUnderlineStyle: tabBarUnderlineStyle,
        renderTab: renderTab,
        renderUnderline: renderUnderline,
        tabs: tabs,
        instanceId: this.instanceId
      };
    } // tslint:disable-next-line:no-shadowed-variable

  }, {
    key: "renderTabBar",
    value: function renderTabBar(tabBarProps, DefaultTabBar) {
      var renderTabBar = this.props.renderTabBar;

      if (renderTabBar === false) {
        return null;
      } else if (renderTabBar) {
        return renderTabBar(tabBarProps);
      } else {
        return /*#__PURE__*/_react["default"].createElement(DefaultTabBar, (0, _extends2["default"])({}, tabBarProps));
      }
    }
  }, {
    key: "getSubElement",
    value: function getSubElement(tab, index, subElements) {
      var defaultPrefix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '$i$-';
      var allPrefix = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '$ALL$';
      var key = tab.key || "".concat(defaultPrefix).concat(index);
      var elements = subElements(defaultPrefix, allPrefix);
      var component = elements[key] || elements[allPrefix];

      if (component instanceof Function) {
        component = component(tab, index);
      }

      return component || null;
    }
  }]);
  return Tabs;
}(_react["default"].PureComponent);

exports.Tabs = Tabs;
Tabs.defaultProps = {
  tabBarPosition: 'top',
  initialPage: 0,
  swipeable: true,
  animated: true,
  prerenderingSiblingsNumber: 1,
  tabs: [],
  destroyInactiveTab: false,
  usePaged: true,
  tabDirection: 'horizontal',
  distanceToChangeTab: 0.3,
  style: {}
};
Tabs.DefaultTabBar = _DefaultTabBar.DefaultTabBar;